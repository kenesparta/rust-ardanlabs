# Rust Ardanlabs Course

Ultimate Rust: This course covers many best practices to help you integrate Rust into your workflow, and let Rust’s tooling work for you. It includes formatting, linting, dependencies, vulnerabilities, code style, and general development advice..

This course is part of the Ultimate Rust track. Not sold separately.

Course materials can be found here.
https://github.com/thebracket/ArdanUltimateRust-5Days
Getting Started with Rust

    1.0: Introduction
    1.1: Setup & Update Rust
    1.2: Setup Dev Environment
    1.3 - IDE Configuration
    1.4 - Rust Fundamentals
    1.5 - Console Text Input
    1.6 - Create a Library
    1.7- World’s Simplest Login System
    1.8 - Enumerations
    1.9 - Structures
    1.10 - Vectors
    1.11 - HashMaps
    1.12 - Serialization/Deserialization
    1.13 - Hashing Passwords
    1.14 - Start a CLI App

Fearless System Thread Concurrency

    2.0 - Introduction
    2.1 - System Threads: Overview
    2.2 - Create Your First Thread
    2.3 - Spawning Threads with Parameters and Closures
    2.4 - Returning Data from Threads
    2.5 - Dividing Workloads
    2.6 - The ThreadBuilder Pattern
    2.7 - Scoped Threads for Easy Local Data Sharing
    2.8 - Sharing Data with Atomics
    2.9 - Sharing Data with Mutexes
    2.10 - Read/Write Locks
    2.11 - Deadlocks, Panics and Poisoning
    2.12 - Sharing Data with Lock-Free Structures
    2.13 - Parking Threads
    2.14 - Sending Data Between Threads with Channels
    2.15 - Sending Functions to Worker Threads
    2.16 - Let’s build a work queue with a thread pool
    2.17 - Thread CPU/Core Affinity
    2.18 - Thread Priority
    2.19 - Making it Easy with Rayon
    2.20 - Scopes and Pooled Threads with Rayon

Async/Await Concurrency

    3.0 - Introduction / Async Overview
    3.1 - Hello Async/Await
    3.2 - Getting Started with Tokio
    3.3 - Working with Tokio Futures: Awaiting, Yielding and Spawning
    3.4 - Blocking Tasks
    3.5 - Unit Testing Tokio
    3.6 - Handling Errors
    3.7 - File I/O
    3.8 - Basic Network I/O
    3.9 - Async Channels (Tokio)
    3.10 - Shared State (Tokio)
    3.11 - Selecting Futures
    3.12 - Pinning
    3.13 - Tokio Tracing
    3.14 - Working with Databases
    3.15 - Axum - A Web Framework built on Tokio
    3.16 - Let’s Build a Thumbnail Server

Memory & Resource Management

    4.0 - Why Haven’t We Manually Managed Any Memory Yet?
    4.1 - The unsafe Keyword
    4.2 - Low-Level Memory Management
    4.3 - The Drop Trait & RAII (Resource Acquisition is Initialization)
    4.4 - Reference Counting
    4.5 - Lifetimes
    4.6 - Traits
    4.7 - Generics
    4.8 - Iterators
    4.9 - Cycles and the Difficulty of Linked Lists
    4.10 - Memory Fragmentation, Allocators and Arenas
    4.11 - Packing, Reordering & Mangling
    4.12 - From Bytes to Types
    4.13 - Safely Interacting with Other Languages & Surprise: Memory Leaks are Safe!

Build a Network Service

    5.0 - Introduction & Planning Our Project
    5.1 - Shared Data Structures
    5.2 - Collection Daemon Mk 1
    5.3 - Collection Server Mk 1
    5.4 - Error Handling in the Collector
    5.5 - Setting the Collector ID
    5.6 - Web Service Mk 1
    5.7 - Web Server
    5.8 - Let’s Use Less Bandwidth
